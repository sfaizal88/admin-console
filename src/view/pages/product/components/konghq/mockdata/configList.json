{
    "result": [
        {
            "scriptContent": "var quantumStateMapping = {\n 'Dead': 'a quantum state embodying the concept of \\'Dead Cat,\\' exploring the duality of existence where quantum uncertainties merge with the tranquility of a resting feline spirit.',\n 'Alive': \"a quantum state under the theme 'Alive Cat,' capturing the dynamic energy and playfulness resonating within the quantum realm and bringing the essence of life to the forefront.\",\n 'Gold': 'a quantum state infused with the essence of gold, blending the classical elegance of metal with the mysterious realms of quantum particles.',\n 'Silver': 'a quantum state resonating with the brilliance of silver, reflecting the essence of both the physical and the quantum.',\n 'Wood': 'a quantum state intertwined with the organic warmth of wood, merging the timeless essence of nature with the cutting-edge concepts of quantum mechanics.',\n 'Water': 'a quantum state inspired by the element of water, where quantum waves dance in harmony with liquid dynamics.',\n 'Fire': 'a quantum state ablaze with the intensity of fire, symbolizing the dynamic and transformative nature of quantum phenomena.',\n 'Earth': 'a quantum state rooted in the stability and grounded energy of the earth, capturing the essence of solidity and foundation within the quantum realm.',\n 'Air': 'a quantum state infused with the lightness and freedom of air, where quantum particles dance in the invisible currents of possibility.',\n 'Metal': 'a quantum state resonating with the strength and conductivity of metal, embodying the fusion of classical durability with quantum complexity.',\n 'Ice': 'a quantum state encapsulated in the crystalline elegance of ice, conveying the delicate balance between frozen stability and the quantum uncertainty.',\n 'Lightning': 'a quantum state charged with the intensity of lightning, symbolizing the sudden and powerful transitions inherent in quantum systems.'\n}\n\nfunction _extractQuantumStateGroup(traitType, value) {\n    var isThisGroup = ['quantumstate', 'quantum state'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    var newValue = quantumStateMapping[value];\n    if (!newValue) {\n        newValue = 'a' + value + ' quantum state';\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'quantumstate',\n        extracted: newValue\n    };\n}\n\nfunction _extractBreedGroup(traitType, value) {\n    var isBreedGroup = traitType.toLowerCase().trim() == 'breed';\n    if (isBreedGroup) {\n        return {\n            traitType: traitType,\n            value: value,\n            group: 'breed',\n            extracted: value.trim()\n        };\n    } else {\n        return null;\n    }\n}\n\nfunction _extractPetGroup(traitType, value) {\n    var isPetGroup = ['pet', 'pets'].includes(traitType.toLowerCase().trim());\n    if (isPetGroup) {\n        return {\n            traitType: traitType,\n            value: value,\n            group: 'pet',\n            extracted: value.trim()\n        };\n    } else {\n        return null;\n    }\n}\n\nfunction _extractBackgroundGroup(traitType, value) {\n    var isBackgroundGroup = traitType.toLowerCase().trim() == 'background';\n    if (isBackgroundGroup) {\n        return {\n            traitType: traitType,\n            value: value,\n            group: 'background',\n            extracted: value.trim()\n        };\n    } else {\n        return null;\n    }\n}\n\nfunction _extractIsGroup(traitType, value) {\n    var tokens = value.trim().split(' ');\n    var matching_the_target_pattern = tokens.length == 2 && tokens[0] == 'is';\n    if (matching_the_target_pattern) {\n        return {\n            traitType: traitType,\n            value: value,\n            group: 'is',\n            extracted: tokens[tokens.length - 1].trim()\n        };\n    } else {\n        return null;\n    }\n}\n\nfunction _extractWithGroup(traitType, value) {\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'with',\n        extracted: value.trim().replace('wears', '')\n            .replace('wearing', '')\n            .replace('is wearing', '')\n            .replace('has', '')\n            .replace('Wears', '')\n            .replace('Wearing', '')\n            .replace('Is Wearing', '')\n            .replace('Has', '')\n    };\n}\n\nfunction _extractHasGroup(traitType, value) {\n    var isThisGroup = ['eyes', 'face', 'mouth', 'mustache', 'mustaches', 'paws', 'paw', 'tails', 'tail', 'wings'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    var needsTraitType = !value.toLowerCase().includes(traitType.toLowerCase());\n    var newValue = needsTraitType ? value + ' ' + traitType : value;\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'has',\n        extracted: newValue\n    };\n}\n\n\nfunction _extractWearingGroup(traitType, value) {\n    var isThisGroup = ['belt', 'belts', 'cap', 'hat', 'clothes', 'necklace', 'shoes', 'trousers', 'pants'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'wearing',\n        extracted: value.trim().replace('wears', '')\n            .replace('wearing', '')\n            .replace('is wearing', '')\n            .replace('has', '').\n            replace('Wears', '')\n            .replace('Wearing', '')\n            .replace('Is Wearing', '')\n            .replace('Has', '')\n    };\n}\n\n\nfunction _extractWeaponLeftGroup(traitType, value) {\n    var isThisGroup = ['weaponleft', 'weapon'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'weaponleft',\n        extracted: value.trim()\n    };\n}\n\n\nfunction _extractWeaponRightGroup(traitType, value) {\n    var isThisGroup = ['weaponright'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'weaponright',\n        extracted: value.trim()\n    };\n}\n\n\nfunction _extractAccessoryLeftGroup(traitType, value) {\n    var isThisGroup = ['accessoryleft'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'accessoryleft',\n        extracted: value.trim()\n    };\n}\n\n\nfunction _extractAccessoryRightGroup(traitType, value) {\n    var isThisGroup = ['accessoryright', 'accessory'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'accessoryright',\n        extracted: value.trim()\n    };\n}\n\nfunction _extractRideGroup(traitType, value) {\n    var isThisGroup = ['ride', 'rides'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'ride',\n        extracted: value.trim()\n    };\n}\n\n\nfunction _extractZodiacGroup(traitType, value) {\n    var isThisGroup = ['zodiac', 'zodiac sign', 'zodiac signs'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    var newValue = 'There is a badge on the top right corner, with the corresponding ' + value + ' zodiac image on it.';\n\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'zodiac',\n        extracted: newValue\n    };\n}\n\nfunction _extract(trait_arg) {\n    var handlers = [\n        _extractQuantumStateGroup, _extractRideGroup,\n        _extractBreedGroup, _extractBackgroundGroup, _extractPetGroup, _extractIsGroup, _extractHasGroup, _extractWearingGroup, _extractZodiacGroup, _extractAccessoryLeftGroup, _extractAccessoryRightGroup, _extractWeaponLeftGroup, _extractWeaponRightGroup, _extractWithGroup\n    ];\n    for (let i = 0; i < handlers.length; i++) {\n        var obj = handlers[i](trait_arg.traitType, trait_arg.value);\n        if (obj != null) {\n            return obj;\n        }\n    }\n}\n\nfunction _makeGroups(traits_identified) {\n    return traits_identified.reduce((accumulator, currentItem) => {\n        const g = currentItem.group;\n        if (!accumulator[g]) {\n            accumulator[g] = [];\n        }\n        accumulator[g].push(currentItem);\n        return accumulator;\n    }, {});\n}\n\nfunction _joinWithCommasAndAnd(values) {\n    if (values.length === 0) {\n        return '';\n    } else if (values.length === 1) {\n        return values[0];\n    } else {\n        const last = values.pop(); // Removes and returns the last element\n        const joined = values.join(', ');\n        return `${joined}, and ${last}`;\n    }\n}\n\nfunction _formatGroup(groups, groupName) {\n    if (!groups.hasOwnProperty(groupName)) {\n        return '';\n    }\n    return _joinWithCommasAndAnd(groups[groupName].map(x => x.extracted));\n}\n\nfunction createPrompt(config, trait_args) {\n    prompt = config.prefix;\n    var traits_identified = trait_args.map(_extract);\n    var groups = _makeGroups(traits_identified);\n    var groupQuantumState = _formatGroup(groups, 'quantumstate');\n    var groupBreed = _formatGroup(groups, 'breed');\n    var groupIs = _formatGroup(groups, 'is');\n    var groupHas = _formatGroup(groups, 'has');\n    var groupWearing = _formatGroup(groups, 'wearing');\n    var groupZodiac = _formatGroup(groups, 'zodiac');\n    var groupAccessoryLeft = _formatGroup(groups, 'accessoryleft');\n    var groupAccessoryRight = _formatGroup(groups, 'accessoryright');\n    var groupWeaponLeft = _formatGroup(groups, 'weaponleft');\n    var groupWeaponRight = _formatGroup(groups, 'weaponright');\n    var groupRide = _formatGroup(groups, 'ride');\n    var groupWith = _formatGroup(groups, 'with');\n    if (groupBreed != '') {\n        prompt = prompt.replace(/image of a [\\w\\s]*[Cc]at/, 'image of a ' + groupBreed + ' cat');\n    }\n\n    if (groupIs != '' && groupWith != '') {\n        prompt = prompt + ' that is ' + groupIs + ' and with ' + groupWith + '.';\n    } else if (groupIs != '') {\n        prompt = prompt + ' that is ' + groupIs + '.'\n    } else if (groupWith != '') {\n        prompt = prompt + ' with ' + groupWith + '.'\n    } else {\n        prompt = prompt + '.'\n    }\n\n    if (groupHas) {\n        prompt = prompt + ' The main character has '+ groupHas + '.'\n    }\n\n    if (groupWearing) {\n        prompt = prompt + ' The main character is wearing '+ groupWearing + '.'\n    }\n\n    if (groupWeaponLeft) {\n        prompt = prompt + ' The main character is holding ' + groupWeaponLeft + ' in the left hand.'\n    }\n\n    if (groupWeaponRight) {\n        prompt = prompt + ' The main character is holding ' + groupWeaponRight + ' in the right hand.'\n    }\n\n    if (groupAccessoryLeft) {\n        prompt = prompt + ' The main character is wearing ' + groupAccessoryRight + ' on the left hand.'\n    }\n\n    if (groupAccessoryRight) {\n        prompt = prompt + ' The main character is wearing ' + groupAccessoryRight + ' on the right hand.'\n    }\n\n    if (groupRide) {\n        prompt = prompt + ' The main character is riding ' + groupRide + '.'\n    }\n\n    var groupPet = _formatGroup(groups, 'pet');\n    if (groupPet != '') {\n        prompt = prompt + ' It is accompanied by a pet ' + groupPet + '.'\n    }\n\n    if(groupZodiac) {\n        prompt = prompt + ' ' + groupZodiac;\n    }\n    if(groupQuantumState) {\n        prompt = prompt + ' The main character has ' + groupQuantumState + '.';\n    }\n    var groupBackground = _formatGroup(groups, 'background')\n    if (groupBackground != '') {\n        prompt = prompt + ' The image has a ' + groupBackground + ' background.'\n\n    } else {\n        ' The image has a solid background.'\n    }\n    prompt = prompt + ' The image should contain the full-body shot of the main character.'\n    prompt = prompt + ' The image should contain one and only one cat.'\n    prompt = prompt + ' The generated image should not contain any text or labels.'\n    return prompt;\n}\n",
            "configText": "{\"id\":\"f44d901\",\"version\":\"1\",\"prefix\":\"I NEED to test how the tool works with extremely simple prompts. DO NOT add any detail, just use it AS-IS: A pixel art image of a cat standing like a human with both feet visible on the ground, facing directly at the viewer,\",\"suffix\":\"\"}",
            "validationTestCase": "{\"newAttributes\":[{\"traitType\":\"mouth\",\"value\":\"wide open\"}],\"baseImage\":{\"image\":\"\",\"traits\":[{\"traitType\":\"hat\",\"value\":\"white cap\"}]}}",
            "validationOk": true
        },
        {
            "scriptContent": "\nvar contentPolicyViolationWordsReplacements = {\n    \"Aladdin Pants\": \"Flowy Harem Pants\"\n}\n\nfunction formatTrait(trait_arg) {\n    return trait_arg.traitType + ': ' + (contentPolicyViolationWordsReplacements[trait_arg.value] || trait_arg.value);\n}\n\n\nfunction createPrompt(config, trait_args) {\n    var traitsFormatted = trait_args.map(formatTrait);\n    prompt = config.prefix + traitsFormatted.join(', ')\n    return prompt;\n}\n",
            "configText": "{\"id\":\"014aa3c\",\"version\":\"1\",\"prefix\":\"Compose a meme story with following descriptions, and then generate a pixel art featuring a cat: \",\"suffix\":\"\"}",
            "validationTestCase": "{\"newAttributes\":[{\"traitType\":\"mouth\",\"value\":\"wide open\"}],\"baseImage\":{\"image\":\"\",\"traits\":[{\"traitType\":\"hat\",\"value\":\"white cap\"}]}}",
            "validationOk": true
        },
        {
            "scriptContent": "var quantumStateMapping = {\n 'Dead': 'a quantum state embodying the concept of \\'Dead Cat,\\' exploring the duality of existence where quantum uncertainties merge with the tranquility of a resting feline spirit.',\n 'Alive': \"a quantum state under the theme 'Alive Cat,' capturing the dynamic energy and playfulness resonating within the quantum realm and bringing the essence of life to the forefront.\",\n 'Gold': 'a quantum state infused with the essence of gold, blending the classical elegance of metal with the mysterious realms of quantum particles.',\n 'Silver': 'a quantum state resonating with the brilliance of silver, reflecting the essence of both the physical and the quantum.',\n 'Wood': 'a quantum state intertwined with the organic warmth of wood, merging the timeless essence of nature with the cutting-edge concepts of quantum mechanics.',\n 'Water': 'a quantum state inspired by the element of water, where quantum waves dance in harmony with liquid dynamics.',\n 'Fire': 'a quantum state ablaze with the intensity of fire, symbolizing the dynamic and transformative nature of quantum phenomena.',\n 'Earth': 'a quantum state rooted in the stability and grounded energy of the earth, capturing the essence of solidity and foundation within the quantum realm.',\n 'Air': 'a quantum state infused with the lightness and freedom of air, where quantum particles dance in the invisible currents of possibility.',\n 'Metal': 'a quantum state resonating with the strength and conductivity of metal, embodying the fusion of classical durability with quantum complexity.',\n 'Ice': 'a quantum state encapsulated in the crystalline elegance of ice, conveying the delicate balance between frozen stability and the quantum uncertainty.',\n 'Lightning': 'a quantum state charged with the intensity of lightning, symbolizing the sudden and powerful transitions inherent in quantum systems.'\n}\n\nfunction _extractQuantumStateGroup(traitType, value) {\n    var isThisGroup = ['quantumstate', 'quantum state'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    var newValue = quantumStateMapping[value];\n    if (!newValue) {\n        newValue = 'a' + value + ' quantum state';\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'quantumstate',\n        extracted: newValue\n    };\n}\n\nfunction _extractBreedGroup(traitType, value) {\n    var isBreedGroup = traitType.toLowerCase().trim() == 'breed';\n    if (isBreedGroup) {\n        return {\n            traitType: traitType,\n            value: value,\n            group: 'breed',\n            extracted: value.trim()\n        };\n    } else {\n        return null;\n    }\n}\n\nfunction _extractPetGroup(traitType, value) {\n    var isPetGroup = ['pet', 'pets'].includes(traitType.toLowerCase().trim());\n    if (isPetGroup) {\n        return {\n            traitType: traitType,\n            value: value,\n            group: 'pet',\n            extracted: value.trim()\n        };\n    } else {\n        return null;\n    }\n}\n\nfunction _extractBackgroundGroup(traitType, value) {\n    var isBackgroundGroup = traitType.toLowerCase().trim() == 'background';\n    if (isBackgroundGroup) {\n        return {\n            traitType: traitType,\n            value: value,\n            group: 'background',\n            extracted: value.trim()\n        };\n    } else {\n        return null;\n    }\n}\n\nfunction _extractIsGroup(traitType, value) {\n    var tokens = value.trim().split(' ');\n    var matching_the_target_pattern = tokens.length == 2 && tokens[0] == 'is';\n    if (matching_the_target_pattern) {\n        return {\n            traitType: traitType,\n            value: value,\n            group: 'is',\n            extracted: tokens[tokens.length - 1].trim()\n        };\n    } else {\n        return null;\n    }\n}\n\nfunction _extractWithGroup(traitType, value) {\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'with',\n        extracted: value.trim().replace('wears', '')\n            .replace('wearing', '')\n            .replace('is wearing', '')\n            .replace('has', '')\n            .replace('Wears', '')\n            .replace('Wearing', '')\n            .replace('Is Wearing', '')\n            .replace('Has', '')\n    };\n}\n\nfunction _extractHasGroup(traitType, value) {\n    var isThisGroup = ['eyes', 'face', 'mouth', 'mustache', 'mustaches', 'paws', 'paw', 'tails', 'tail', 'wings'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    var needsTraitType = !value.toLowerCase().includes(traitType.toLowerCase());\n    var newValue = needsTraitType ? value + ' ' + traitType : value;\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'has',\n        extracted: newValue\n    };\n}\n\n\nfunction _extractWearingGroup(traitType, value) {\n    var isThisGroup = ['belt', 'belts', 'cap', 'hat', 'clothes', 'necklace', 'shoes', 'trousers', 'pants'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'wearing',\n        extracted: value.trim().replace('wears', '')\n            .replace('wearing', '')\n            .replace('is wearing', '')\n            .replace('has', '').\n            replace('Wears', '')\n            .replace('Wearing', '')\n            .replace('Is Wearing', '')\n            .replace('Has', '')\n    };\n}\n\n\nfunction _extractWeaponLeftGroup(traitType, value) {\n    var isThisGroup = ['weaponleft', 'weapon'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'weaponleft',\n        extracted: value.trim()\n    };\n}\n\n\nfunction _extractWeaponRightGroup(traitType, value) {\n    var isThisGroup = ['weaponright'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'weaponright',\n        extracted: value.trim()\n    };\n}\n\n\nfunction _extractAccessoryLeftGroup(traitType, value) {\n    var isThisGroup = ['accessoryleft'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'accessoryleft',\n        extracted: value.trim()\n    };\n}\n\n\nfunction _extractAccessoryRightGroup(traitType, value) {\n    var isThisGroup = ['accessoryright', 'accessory'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'accessoryright',\n        extracted: value.trim()\n    };\n}\n\nfunction _extractRideGroup(traitType, value) {\n    var isThisGroup = ['ride', 'rides'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'ride',\n        extracted: value.trim()\n    };\n}\n\n\nfunction _extractZodiacGroup(traitType, value) {\n    var isThisGroup = ['zodiac', 'zodiac sign', 'zodiac signs'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    var newValue = 'There is a badge on the top right corner, with the corresponding ' + value + ' zodiac image on it.';\n\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'zodiac',\n        extracted: newValue\n    };\n}\n\nfunction _extract(trait_arg) {\n    var handlers = [\n        _extractQuantumStateGroup, _extractRideGroup,\n        _extractBreedGroup, _extractBackgroundGroup, _extractPetGroup, _extractIsGroup, _extractHasGroup, _extractWearingGroup, _extractZodiacGroup, _extractAccessoryLeftGroup, _extractAccessoryRightGroup, _extractWeaponLeftGroup, _extractWeaponRightGroup, _extractWithGroup\n    ];\n    for (let i = 0; i < handlers.length; i++) {\n        var obj = handlers[i](trait_arg.traitType, trait_arg.value);\n        if (obj != null) {\n            return obj;\n        }\n    }\n}\n\nfunction _makeGroups(traits_identified) {\n    return traits_identified.reduce((accumulator, currentItem) => {\n        const g = currentItem.group;\n        if (!accumulator[g]) {\n            accumulator[g] = [];\n        }\n        accumulator[g].push(currentItem);\n        return accumulator;\n    }, {});\n}\n\nfunction _joinWithCommasAndAnd(values) {\n    if (values.length === 0) {\n        return '';\n    } else if (values.length === 1) {\n        return values[0];\n    } else {\n        const last = values.pop(); // Removes and returns the last element\n        const joined = values.join(', ');\n        return `${joined}, and ${last}`;\n    }\n}\n\nfunction _formatGroup(groups, groupName) {\n    if (!groups.hasOwnProperty(groupName)) {\n        return '';\n    }\n    return _joinWithCommasAndAnd(groups[groupName].map(x => x.extracted));\n}\n\nfunction createPrompt(config, trait_args) {\n    prompt = config.prefix;\n    var traits_identified = trait_args.map(_extract);\n    var groups = _makeGroups(traits_identified);\n    var groupQuantumState = _formatGroup(groups, 'quantumstate');\n    var groupBreed = _formatGroup(groups, 'breed');\n    var groupIs = _formatGroup(groups, 'is');\n    var groupHas = _formatGroup(groups, 'has');\n    var groupWearing = _formatGroup(groups, 'wearing');\n    var groupZodiac = _formatGroup(groups, 'zodiac');\n    var groupAccessoryLeft = _formatGroup(groups, 'accessoryleft');\n    var groupAccessoryRight = _formatGroup(groups, 'accessoryright');\n    var groupWeaponLeft = _formatGroup(groups, 'weaponleft');\n    var groupWeaponRight = _formatGroup(groups, 'weaponright');\n    var groupRide = _formatGroup(groups, 'ride');\n    var groupWith = _formatGroup(groups, 'with');\n    if (groupBreed != '') {\n        prompt = prompt.replace(/image of a [\\w\\s]*[Cc]at/, 'image of a ' + groupBreed + ' cat');\n    }\n\n    if (groupIs != '' && groupWith != '') {\n        prompt = prompt + ' that is ' + groupIs + ' and with ' + groupWith + '.';\n    } else if (groupIs != '') {\n        prompt = prompt + ' that is ' + groupIs + '.'\n    } else if (groupWith != '') {\n        prompt = prompt + ' with ' + groupWith + '.'\n    } else {\n        prompt = prompt + '.'\n    }\n\n    if (groupHas) {\n        prompt = prompt + ' The main character has '+ groupHas + '.'\n    }\n\n    if (groupWearing) {\n        prompt = prompt + ' The main character is wearing '+ groupWearing + '.'\n    }\n\n    if (groupWeaponLeft) {\n        prompt = prompt + ' The main character is holding ' + groupWeaponLeft + ' in the left hand.'\n    }\n\n    if (groupWeaponRight) {\n        prompt = prompt + ' The main character is holding ' + groupWeaponRight + ' in the right hand.'\n    }\n\n    if (groupAccessoryLeft) {\n        prompt = prompt + ' The main character is wearing ' + groupAccessoryRight + ' on the left hand.'\n    }\n\n    if (groupAccessoryRight) {\n        prompt = prompt + ' The main character is wearing ' + groupAccessoryRight + ' on the right hand.'\n    }\n\n    if (groupRide) {\n        prompt = prompt + ' The main character is riding ' + groupRide + '.'\n    }\n\n    var groupPet = _formatGroup(groups, 'pet');\n    if (groupPet != '') {\n        prompt = prompt + ' It is accompanied by a pet ' + groupPet + '.'\n    }\n\n    if(groupZodiac) {\n        prompt = prompt + ' ' + groupZodiac;\n    }\n    if(groupQuantumState) {\n        prompt = prompt + ' The main character has ' + groupQuantumState + '.';\n    }\n    var groupBackground = _formatGroup(groups, 'background')\n    if (groupBackground != '') {\n        prompt = prompt + ' The image has a ' + groupBackground + ' background.'\n\n    } else {\n        ' The image has a solid background.'\n    }\n    prompt = prompt + ' The image should contain the full-body shot of the main character.'\n    prompt = prompt + ' The image should contain one and only one cat.'\n    prompt = prompt + ' The generated image should not contain any text or labels.'\n    return prompt;\n}\n",
            "configText": "{\"id\":\"f44d901\",\"version\":\"1\",\"prefix\":\"I NEED to test how the tool works with extremely simple prompts. DO NOT add any detail, just use it AS-IS: A pixel art image of a cat standing like a human with both feet visible on the ground, facing directly at the viewer,\",\"suffix\":\"\"}",
            "validationTestCase": "{\"newAttributes\":[{\"traitType\":\"mouth\",\"value\":\"wide open\"}],\"baseImage\":{\"image\":\"\",\"traits\":[{\"traitType\":\"hat\",\"value\":\"white cap\"}]}}",
            "validationOk": true
        },
        {
            "scriptContent": "var quantumStateMapping = {\n 'Dead': 'a quantum state embodying the concept of \\'Dead Cat,\\' exploring the duality of existence where quantum uncertainties merge with the tranquility of a resting feline spirit.',\n 'Alive': \"a quantum state under the theme 'Alive Cat,' capturing the dynamic energy and playfulness resonating within the quantum realm and bringing the essence of life to the forefront.\",\n 'Gold': 'a quantum state infused with the essence of gold, blending the classical elegance of metal with the mysterious realms of quantum particles.',\n 'Silver': 'a quantum state resonating with the brilliance of silver, reflecting the essence of both the physical and the quantum.',\n 'Wood': 'a quantum state intertwined with the organic warmth of wood, merging the timeless essence of nature with the cutting-edge concepts of quantum mechanics.',\n 'Water': 'a quantum state inspired by the element of water, where quantum waves dance in harmony with liquid dynamics.',\n 'Fire': 'a quantum state ablaze with the intensity of fire, symbolizing the dynamic and transformative nature of quantum phenomena.',\n 'Earth': 'a quantum state rooted in the stability and grounded energy of the earth, capturing the essence of solidity and foundation within the quantum realm.',\n 'Air': 'a quantum state infused with the lightness and freedom of air, where quantum particles dance in the invisible currents of possibility.',\n 'Metal': 'a quantum state resonating with the strength and conductivity of metal, embodying the fusion of classical durability with quantum complexity.',\n 'Ice': 'a quantum state encapsulated in the crystalline elegance of ice, conveying the delicate balance between frozen stability and the quantum uncertainty.',\n 'Lightning': 'a quantum state charged with the intensity of lightning, symbolizing the sudden and powerful transitions inherent in quantum systems.'\n}\n\nfunction _extractQuantumStateGroup(traitType, value) {\n    var isThisGroup = ['quantumstate', 'quantum state'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    var newValue = quantumStateMapping[value];\n    if (!newValue) {\n        newValue = 'a' + value + ' quantum state';\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'quantumstate',\n        extracted: newValue\n    };\n}\n\nfunction _extractBreedGroup(traitType, value) {\n    var isBreedGroup = traitType.toLowerCase().trim() == 'breed';\n    if (isBreedGroup) {\n        return {\n            traitType: traitType,\n            value: value,\n            group: 'breed',\n            extracted: value.trim()\n        };\n    } else {\n        return null;\n    }\n}\n\nfunction _extractPetGroup(traitType, value) {\n    var isPetGroup = ['pet', 'pets'].includes(traitType.toLowerCase().trim());\n    if (isPetGroup) {\n        return {\n            traitType: traitType,\n            value: value,\n            group: 'pet',\n            extracted: value.trim()\n        };\n    } else {\n        return null;\n    }\n}\n\nfunction _extractBackgroundGroup(traitType, value) {\n    var isBackgroundGroup = traitType.toLowerCase().trim() == 'background';\n    if (isBackgroundGroup) {\n        return {\n            traitType: traitType,\n            value: value,\n            group: 'background',\n            extracted: value.trim()\n        };\n    } else {\n        return null;\n    }\n}\n\nfunction _extractIsGroup(traitType, value) {\n    var tokens = value.trim().split(' ');\n    var matching_the_target_pattern = tokens.length == 2 && tokens[0] == 'is';\n    if (matching_the_target_pattern) {\n        return {\n            traitType: traitType,\n            value: value,\n            group: 'is',\n            extracted: tokens[tokens.length - 1].trim()\n        };\n    } else {\n        return null;\n    }\n}\n\nfunction _extractWithGroup(traitType, value) {\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'with',\n        extracted: value.trim().replace('wears', '')\n            .replace('wearing', '')\n            .replace('is wearing', '')\n            .replace('has', '')\n            .replace('Wears', '')\n            .replace('Wearing', '')\n            .replace('Is Wearing', '')\n            .replace('Has', '')\n    };\n}\n\nfunction _extractHasGroup(traitType, value) {\n    var isThisGroup = ['eyes', 'face', 'mouth', 'mustache', 'mustaches', 'paws', 'paw', 'tails', 'tail', 'wings'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    var needsTraitType = !value.toLowerCase().includes(traitType.toLowerCase());\n    var newValue = needsTraitType ? value + ' ' + traitType : value;\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'has',\n        extracted: newValue\n    };\n}\n\n\nfunction _extractWearingGroup(traitType, value) {\n    var isThisGroup = ['belt', 'belts', 'cap', 'hat', 'clothes', 'necklace', 'shoes', 'trousers', 'pants'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'wearing',\n        extracted: value.trim().replace('wears', '')\n            .replace('wearing', '')\n            .replace('is wearing', '')\n            .replace('has', '').\n            replace('Wears', '')\n            .replace('Wearing', '')\n            .replace('Is Wearing', '')\n            .replace('Has', '')\n    };\n}\n\n\nfunction _extractWeaponLeftGroup(traitType, value) {\n    var isThisGroup = ['weaponleft', 'weapon'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'weaponleft',\n        extracted: value.trim()\n    };\n}\n\n\nfunction _extractWeaponRightGroup(traitType, value) {\n    var isThisGroup = ['weaponright'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'weaponright',\n        extracted: value.trim()\n    };\n}\n\n\nfunction _extractAccessoryLeftGroup(traitType, value) {\n    var isThisGroup = ['accessoryleft'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'accessoryleft',\n        extracted: value.trim()\n    };\n}\n\n\nfunction _extractAccessoryRightGroup(traitType, value) {\n    var isThisGroup = ['accessoryright', 'accessory'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'accessoryright',\n        extracted: value.trim()\n    };\n}\n\nfunction _extractRideGroup(traitType, value) {\n    var isThisGroup = ['ride', 'rides'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'ride',\n        extracted: value.trim()\n    };\n}\n\n\nfunction _extractZodiacGroup(traitType, value) {\n    var isThisGroup = ['zodiac', 'zodiac sign', 'zodiac signs'].includes(traitType.toLowerCase().trim());\n    if (!isThisGroup) {\n        return null\n    }\n    var newValue = 'There is a badge on the top right corner, with the corresponding ' + value + ' zodiac image on it.';\n\n    return {\n        traitType: traitType,\n        value: value,\n        group: 'zodiac',\n        extracted: newValue\n    };\n}\n\nfunction _extract(trait_arg) {\n    var handlers = [\n        _extractQuantumStateGroup, _extractRideGroup,\n        _extractBreedGroup, _extractBackgroundGroup, _extractPetGroup, _extractIsGroup, _extractHasGroup, _extractWearingGroup, _extractZodiacGroup, _extractAccessoryLeftGroup, _extractAccessoryRightGroup, _extractWeaponLeftGroup, _extractWeaponRightGroup, _extractWithGroup\n    ];\n    for (let i = 0; i < handlers.length; i++) {\n        var obj = handlers[i](trait_arg.traitType, trait_arg.value);\n        if (obj != null) {\n            return obj;\n        }\n    }\n}\n\nfunction _makeGroups(traits_identified) {\n    return traits_identified.reduce((accumulator, currentItem) => {\n        const g = currentItem.group;\n        if (!accumulator[g]) {\n            accumulator[g] = [];\n        }\n        accumulator[g].push(currentItem);\n        return accumulator;\n    }, {});\n}\n\nfunction _joinWithCommasAndAnd(values) {\n    if (values.length === 0) {\n        return '';\n    } else if (values.length === 1) {\n        return values[0];\n    } else {\n        const last = values.pop(); // Removes and returns the last element\n        const joined = values.join(', ');\n        return `${joined}, and ${last}`;\n    }\n}\n\nfunction _formatGroup(groups, groupName) {\n    if (!groups.hasOwnProperty(groupName)) {\n        return '';\n    }\n    return _joinWithCommasAndAnd(groups[groupName].map(x => x.extracted));\n}\n\nfunction createPrompt(config, trait_args) {\n    prompt = config.prefix;\n    var traits_identified = trait_args.map(_extract);\n    var groups = _makeGroups(traits_identified);\n    var groupQuantumState = _formatGroup(groups, 'quantumstate');\n    var groupBreed = _formatGroup(groups, 'breed');\n    var groupIs = _formatGroup(groups, 'is');\n    var groupHas = _formatGroup(groups, 'has');\n    var groupWearing = _formatGroup(groups, 'wearing');\n    var groupZodiac = _formatGroup(groups, 'zodiac');\n    var groupAccessoryLeft = _formatGroup(groups, 'accessoryleft');\n    var groupAccessoryRight = _formatGroup(groups, 'accessoryright');\n    var groupWeaponLeft = _formatGroup(groups, 'weaponleft');\n    var groupWeaponRight = _formatGroup(groups, 'weaponright');\n    var groupRide = _formatGroup(groups, 'ride');\n    var groupWith = _formatGroup(groups, 'with');\n    if (groupBreed != '') {\n        prompt = prompt.replace(/image of a [\\w\\s]*[Cc]at/, 'image of a ' + groupBreed + ' cat');\n    }\n\n    if (groupIs != '' && groupWith != '') {\n        prompt = prompt + ' that is ' + groupIs + ' and with ' + groupWith + '.';\n    } else if (groupIs != '') {\n        prompt = prompt + ' that is ' + groupIs + '.'\n    } else if (groupWith != '') {\n        prompt = prompt + ' with ' + groupWith + '.'\n    } else {\n        prompt = prompt + '.'\n    }\n\n    if (groupHas) {\n        prompt = prompt + ' The main character has '+ groupHas + '.'\n    }\n\n    if (groupWearing) {\n        prompt = prompt + ' The main character is wearing '+ groupWearing + '.'\n    }\n\n    if (groupWeaponLeft) {\n        prompt = prompt + ' The main character is holding ' + groupWeaponLeft + ' in the left hand.'\n    }\n\n    if (groupWeaponRight) {\n        prompt = prompt + ' The main character is holding ' + groupWeaponRight + ' in the right hand.'\n    }\n\n    if (groupAccessoryLeft) {\n        prompt = prompt + ' The main character is wearing ' + groupAccessoryRight + ' on the left hand.'\n    }\n\n    if (groupAccessoryRight) {\n        prompt = prompt + ' The main character is wearing ' + groupAccessoryRight + ' on the right hand.'\n    }\n\n    if (groupRide) {\n        prompt = prompt + ' The main character is riding ' + groupRide + '.'\n    }\n\n    var groupPet = _formatGroup(groups, 'pet');\n    if (groupPet != '') {\n        prompt = prompt + ' It is accompanied by a pet ' + groupPet + '.'\n    }\n\n    if(groupZodiac) {\n        prompt = prompt + ' ' + groupZodiac;\n    }\n    if(groupQuantumState) {\n        prompt = prompt + ' The main character has ' + groupQuantumState + '.';\n    }\n    var groupBackground = _formatGroup(groups, 'background')\n    if (groupBackground != '') {\n        prompt = prompt + ' The image has a ' + groupBackground + ' background.'\n\n    } else {\n        ' The image has a solid background.'\n    }\n    prompt = prompt + ' The image should contain the full-body shot of the main character.'\n    prompt = prompt + ' The image should contain one and only one cat.'\n    prompt = prompt + ' The generated image should not contain any text or labels.'\n    return prompt;\n}\n",
            "configText": "{\"id\":\"f44d901\",\"version\":\"1\",\"prefix\":\"I NEED to test how the tool works with extremely simple prompts. DO NOT add any detail, just use it AS-IS: A pixel art image of a cat standing like a human with both feet visible on the ground, facing directly at the viewer,\",\"suffix\":\"\"}",
            "validationTestCase": "{\"newAttributes\":[{\"traitType\":\"mouth\",\"value\":\"wide open\"}],\"baseImage\":{\"image\":\"\",\"traits\":[{\"traitType\":\"hat\",\"value\":\"white cap\"}]}}",
            "validationOk": true
        }
    ]
}